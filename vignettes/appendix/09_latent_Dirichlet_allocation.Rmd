---
title: "Section 9: LATENT DIRICHLET ALLOCATION"
author: "Pratheepa Jeganathan"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: BiocStyle::html_document
params:
  K: 11
  R: 2000
resource_files:
  - topic_dis_all_11.png
  - circular_plot_plant_all_K_11.png
  - Rhat_plant_all_K_11.png
  - ess_bulk_plant_all_K_11.png
  - model_assesment_hist_all_obs_sim_K_11.png
---

The input parameters to run this R Markdown are $K$ number of topics and R - number of interations for each Markov chain.

We removed DNA contaminants using BARBI. Then, we choose ASVs that have at least 25 counts in at least two specimens.

In microbiome data, bacteria that have similar functionalities can co-occure as latent communities. In this data set, we are interested infer on the latent communties when we use original and modified PNA clams. To infer about these latent communities, we use topic modeling.  

For the topic modeling, we choose Aster-plants. These specimens were sequenced with original and modified pPNA types.

We set the hyper-parameters $\alpha$ and $\gamma$ less than one to generate mixtures that are different from each other. We choose 0.8 for $\alpha$ across all samples so that we avoid generating unrealistic topics. 

We estimate the parameters using HMC NUTS with four chains and 2000 iterations. Out of these 2000 iterations, 1000 iterations were used as warmup samples. 

We align the topics from four different chain and compute posterior log likelihood, $\hat{R}$ (split), effective sample size (ESS). 

For the model with optimal topic, we do the predictive model check with simulated data, observed data, and a statistic $G\left(K_{ij} \right)$

With the optimal topic, we visualize the topic distribution in each specimen and ASVs distribution in each topic.

With the optimal topic, we do differential topic analysis

```{r read_arg}
K <- params$K
K
iter <- params$R
iter
```


```{r include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  fig.width = 7, 
  fig.height = 4, 
  fig.align = 'center',
  message = FALSE, 
  warning = FALSE
  )
```

```{r}
library(phyloseq)
library(tidyverse)
library(genefilter) #KOverA
library(Rcpp)
library(rstan)
library(randomcoloR)# distinctColorPalette(n)
library(DESeq2)

devtools::load_all()
```


```{r}
theme_set(theme_minimal())
theme_update(
  text = element_text(size = 10),
  legend.text = element_text(size = 10)
)
```

## Data

```{r}

threshold <- kOverA(2, A = 25) 
psE_BARBI <- phyloseq::filter_taxa(
  psE_BARBI, 
  threshold, TRUE) 

psE_BARBI

ps <- psE_BARBI
rm(psE_BARBI)
ps <- prune_taxa(taxa_sums(ps) > 0, ps)
ps

```

### Edit specimen names

We edit specimen names and identify Asteraceae and non-Asteraceae plants.

```{r}
sam_names <- str_replace(sample_names(ps), "E106", "E-106")
sam_names <- str_replace(sam_names, "_F_filt.fastq.gz", "")
sam_names <- str_replace(sam_names, "Connor-", "E")
sample_names(ps) <- sam_names
sample_data(ps)$X <- sam_names
sample_data(ps)$unique_names <- sam_names
aster <- c("142","143","15","ST","22","40")
non_aster <- c("33", "71", "106")

paired_aster <- c("E-142-1", "E142-1", "E-142-5", "E142-5", "E-142-10", "E142-10", "E-143-2", "E143-2", "E-143-7", "E143-7", "E-15-1", "E15-1", "ST-CAZ-4-R-O", "ST-CAZ-4-R-M", "ST-SAL-22-R-O", "ST-SAL-22-R-M", "ST-TRI-10-R-O", "ST-TRI-10-R-M")
paired_non_aster <- c("E33-7", "E-33-7", "E33-8", "E-33-8", "E33-9", "E-33-9", "E71-10", "E-71-10","E71-2","E-71-2" ,"E71-3", "E-71-3", "E106-1", "E-106-1", "E106-3", "E-106-3", "E106-4", "E-106-4")
paired_specimens <- c(paired_aster, paired_non_aster)
```


```{r}
# We will use 9 colors for 9 different plants
plant_colors <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", "purple")
```

## Topic modeling

### Set-up data
```{r}
x <- t(get_taxa(ps))
dimnames(x) <- NULL

# theta[d] ~ dirichlet(alpha), alpha pseudocount for each topic
# beta[k] ~ dirichlet(gamma), gamma pseudocount for each ASV in each topic
print(K)
stan.data <- list(K = K, 
  V = ncol(x), 
  D = nrow(x), 
  n = x, 
  alpha = rep(.8, K), 
  gamma = rep(.5, ncol(x))
)
```

### Posterior sampling 
$\theta$ and $B = \left[\beta_{1}, \cdots, \beta_{K} \right]^{T}.$

```{r eval=FALSE}
fileN <- paste0(
  "JABES_Endo_all_K_",
  K,
  "_ite_",
  iter,
  ".RData"
  )

stan.fit <- stan(file = "./lda.stan", 
  data = stan.data, 
  iter = iter, 
  chains = 4, 
  sample_file = NULL,
  diagnostic_file = NULL,
  cores = 4,
  control = list(adapt_delta = 0.9),
  save_dso = TRUE,
  algorithm = "NUTS")

save(stan.fit, file = fileN)
```

```{r eval=FALSE}
load(file = fileN)
```


### Extract posterior samples
```{r eval=FALSE}
samples <- rstan::extract(
  stan.fit, 
  permuted = TRUE, 
  inc_warmup = FALSE, 
  include = TRUE)# samples is a list
```

### Alignment
- Create a Topic $*$ Chain matrix
```{r eval=FALSE}
theta <- samples$theta 
# dim(theta)
aligned <- alignmentMatrix(
  theta, 
  ps, 
  K, 
  iter = iter,
  chain = 4,
  SampleID_name = "unique_names"
  )

theta_aligned <- thetaAligned(
  theta, 
  K, 
  aligned, 
  iter = iter, 
  chain = 4
  )

dimnames(theta_aligned)[[2]] <- sample_names(ps)
dimnames(theta_aligned)[[3]] <- c(paste0("Topic_", seq(1,K)))

# array to a dataframe
theta_all <- reshape2::melt(theta_aligned)

colnames(theta_all) <- c(
"iteration", 
"Sample", 
"Topic", 
"topic.dis"
)

theta_all$Chain <- paste0(
  "Chain ", 
  rep(seq(1, 4), 
      each = (iter/2)
      )
  )

sam <- sample_data(ps) %>% 
  data.frame()

theta_all$Sample <- theta_all$Sample %>%
  as.character()

theta_all <- left_join(
  theta_all, 
  sam, 
  by =c("Sample"= "unique_names")
  )

theta_all$Chain <- factor(theta_all$Chain)
theta_all$Topic <- factor(theta_all$Topic)
theta_all$Sample <- factor(theta_all$Sample)
theta_all$pna <- factor(theta_all$pna)
```

### Plot the topic distribution in all chains

- facet by pna and aster or non-aster plant type.

```{r eval=FALSE}
theta_summary <- theta_all %>% 
  group_by(
    Sample, 
    Topic, 
    pna
    ) %>% 
  summarize(
    median.topic.dis = median(topic.dis)
    ) %>% 
  ungroup() %>% 
  mutate(
    Topic = factor(
      Topic, 
      levels = rev(str_c("Topic_",1:K)
                   )
      )
    )

p <- ggplot(
  theta_summary, 
  aes(x = pna, 
      y = Topic,
      fill = pna)
  )
p <- p+
  geom_tile(
    aes(alpha = median.topic.dis)
    ) +
  facet_grid(
    .~Sample,
    scale = "free"
    )+
  xlab("pna") +
  scale_fill_manual(
    name = "pna", 
    values = c("steelblue1","green3")
    ) +
  scale_alpha(
    name = "median topic distribution"
    ) +
  theme_minimal(
    base_size = 20
    ) +  
  theme(
    plot.title = element_text(hjust = 0.5),
    strip.text.x = element_text(angle = 90)
    )
p
ggsave(paste0("topic_dis_all_",K, ".png")), p, width = 30, height = 16)
```

```{r echo=FALSE, out.width="70%", fig.caption = "Figure 6", fig.align="center"}
knitr::include_graphics(paste0("topic_dis_all_",K,".png"))
```


### ASV distribution

```{r eval=FALSE}
# an array (iterations *topic * ASV)
beta <- samples$beta 

# an array (iterations *topic * ASV)
beta_aligned <- betaAligned(
  beta, 
  K, 
  aligned, 
  iter = iter, 
  chain = 4
  ) 


# array to data frame
beta_hat <- beta_aligned %>%
  reshape2::melt(
    varnames = c("iterations", 
                 "topic", 
                 "rsv_ix"),
    value.name = "beta_h") %>% 
  as_tibble()

beta_hat$rsv <- rownames(
  tax_table(ps)
  )[beta_hat$rsv_ix]

# join taxa_table with beta_hat

## If we use a taxonomy level with NA, 
## we can replace the taxonomy level with 
## one level before this level
#taxa$Class[which(is.na(taxa$Class))] = taxa$Phylum[which(is.na(taxa$Class))]
taxa <- tax_table(ps) %>%  
  as.data.frame() %>% 
  as_tibble() 

taxa$rsv <- rownames(
  tax_table(ps)
  )

beta_hat <- beta_hat %>%
  left_join(
    taxa, 
    by = "rsv"
    ) %>% 
  mutate(
    topic = paste("Topic", topic)
    )

# Filtering ASVs for visualization:
## We can filter by ASVs proportion in all topics.

beta_hat$Class <- factor(beta_hat$Class)
beta_hat$rsv <- factor(beta_hat$rsv)
beta_hat$rsv_ix <- factor(beta_hat$rsv_ix)
beta_hat$topic <- factor(beta_hat$topic)

# We plot the median of posterior sample and keep all taxonomy for each ASV.
beta_summary <- beta_hat %>% 
  dplyr::group_by(
    rsv_ix, 
    topic
    ) %>% 
  dplyr::summarise(
    beta_median = median(beta_h),
    rsv = rsv[1],
    Phylum = Phylum[1],
    Class = Class[1],
    Order = Order[1],
    Family = Family[1],
    Genus = Genus[1]
  )

usethis::use_data(beta_summary)

#######
beta_subset <- beta_summary 

beta_subset$rsv_ix <- rep(
  seq_len(
    nrow(beta_subset) / K
    ), 
  each = K
  )


beta_subset <- beta_subset %>% 
  arrange(
    rsv_ix, 
    topic
    )

beta_subset <- beta_subset %>%
  mutate(
    Class = factor(
      Class, 
      levels = unique(beta_subset$Class)
      ),
    Topic = str_remove(topic, "Topic ")
    )


beta_subset$Class <- beta_subset$Class %>% 
  as.character()

beta_subset$Class <- ifelse(
  is.na(beta_subset$Class), 
  "other", 
  beta_subset$Class
  )

beta_subset$Class <- factor(
  beta_subset$Class
  )


beta_subset$Topic <- factor(
  beta_subset$Topic,
  levels = seq(1,K) %>% 
    as.character()
  )

####

beta_subset_wide <- dplyr::select(
  beta_subset, 
  rsv_ix, 
  rsv, 
  topic, 
  Class, 
  beta_median
  ) %>% 
  as.data.frame()

beta_subset_wide <- dplyr::select(
  beta_subset_wide, 
  -rsv_ix
  )

beta_subset_wide <- tidyr::spread(
  beta_subset_wide, 
  key = topic, 
  value = beta_median
  )

rownames(beta_subset_wide) <- beta_subset_wide$rsv

beta_subset_wide$Class <- beta_subset_wide$Class %>%
  as.character()

beta_subset_wide$Class <- ifelse(
  is.na(beta_subset_wide$Class), 
  "other", 
  beta_subset_wide$Class)

beta_subset_wide$Class <- factor(
  beta_subset_wide$Class
  )

# Choose rsv if at least in one topic the feature distribution is greater than the cutoff = 0.008
choose_rsv_logical <- apply(
  beta_subset_wide[, 3:dim(beta_subset_wide)[2]], 
  1, 
  function(x){
    sum(x >= 0.008) >= 1
    }
  )

choose_rsv <- beta_subset_wide$rsv[which(
  choose_rsv_logical
  )] %>% 
  as.character()

  
beta_subset_wide <- beta_subset_wide[choose_rsv, ]

tree <- phyloseq::phy_tree(
  prune_taxa(
    choose_rsv, 
    ps
    )
  )

circ <- ggtree(
  tree, 
  layout = "circular"
  )

beta_subset_wide <- beta_subset_wide[tree$tip.label, ]

beta_subset_wide <- beta_subset_wide[ , c("rsv", "Class", paste0("Topic ", seq(1,K)))]

color <- distinctColorPalette(
  length(
    unique(
      beta_subset_wide$Class
      )
    )
  )

color_topic <- rainbow(K)

## in circular plot, ASVs will be labeled by Class 
df <- data.frame(
  Class = beta_subset_wide$Class
  )

rownames(df) <- tree$tip.label


df2 <- beta_subset_wide[, 3:dim(beta_subset_wide)[2]]

rownames(df2) <- tree$tip.label


## append Class to phylogenetic tree
p <- gheatmap(
  p = circ, 
  data = df, 
  offset = -.1, 
  width = .1,
  colnames_angle = 95, 
  colnames_offset_y = .5, 
  font.size = 5) + 
  scale_fill_manual(
    values = color, 
    name = "Class"
    )


for(i in 1:K){
  if(i == 1){
    p <- p + 
      new_scale_fill()# to make once fill scale
  }
  df2_i <- dplyr::select(
    beta_subset_wide, (i+2)
    )
  rownames(df2_i) <- tree$tip.label
  p <- gheatmap(
    p,
    df2_i,
    offset = i*.08, 
    width = .1,
    colnames_angle = 90, 
    colnames_offset_y = .25, 
    font.size = 6,
    high = "dodgerblue",
    low = "gray98",
    legend_title = expression(beta[k])) 
}

p <- p + 
  theme_minimal(
    base_size = 20
    ) +  
  theme(
    plot.title = element_text(hjust = 0.5)
    )

ggsave(paste0("circular_plot_plant_all_K_", K, ".png"), p, width = 28, height = 22)
```

```{r echo=FALSE, out.width="100%", fig.caption = "Figure 7: ASV distribution over topics in all specimens", fig.align="center"}
knitr::include_graphics(paste0("circular_plot_plant_all_K_", K, ".png"))
```

### Diagnostic and model assessment plots

Model assessment

```{r eval=FALSE}
samples <- rstan::extract(
  stan.fit,
  permuted = TRUE,
  inc_warmup = FALSE,
  include = TRUE)# samples is a list

x <- get_taxa(ps) %>%
  t()

dimnames(x) <- NULL
x_max_asv <- apply(
  x %>% data.frame , 
  2, 
  max)

x_max_asv <- data.frame(
  x_max_asv = x_max_asv
  )

# draws from posterior predictive distribution
x_sim <- samples$x_sim # iteration * samples * ASVs
# Choose only the first chain
x_sim <- x_sim[1:(iter/2), ,] # For each iteration, simulated data is x_sim[i, ,]
sim_ite <- dim(x_sim)[1]

#Find maximum of each asv for each replication
max_all <- data.frame()
x_sim_i <- x_sim[1, ,]
max_x_sim_i <- apply(
  x_sim_i %>% data.frame , 
  2, 
  max
  )
max_all <- data.frame(max_x_sim_i)

for(i in 1:sim_ite){
  x_sim_i <- x_sim[i, ,]
  max_x_sim_i <- apply(
    x_sim_i %>% data.frame , 
    2, 
    max)
  max_all <- cbind(max_all, max_x_sim_i)
}

colnames(max_all) <- c(
  paste0(
    "x_max_rep", 
    seq(1, sim_ite)
         )
  )

rownames(max_all) <- paste0(
  "ASV_", 
  seq(1, ntaxa(ps)),
  "_", 
  tax_table(ps)[,"Class"]
  )

max_all <- max_all %>% t()
## choose some of asvs for Posterior predictive check (these indexes are considered to avoid if ASV's Class is missing)
max_all <- max_all[, c(1, 3, 10:14, 19:26, 36, 51:53, 148)]
max_all_long <- melt(max_all)

# observed stat data frame
x_max_asv <- data.frame(
  Var1 = rep(
    "x_max_obs", 
    dim(x_max_asv)[1]
    ), 
  Var2 = paste0(
    "ASV_", 
    seq(1, ntaxa(ps)),
    "_", 
    tax_table(ps)[,"Class"]
    ), 
  value = x_max_asv$x_max_asv
  )

x_max_asv <- x_max_asv[c(1,3,10:14,19:26,36,51:53, 148),]


p_hist <- ggplot(
  data = max_all_long
  ) + 
  geom_histogram(
    aes(
      x = value, 
      group = Var2
      ),
    color = "blue", 
    fill = "blue",
    bins = 50) + 
  xlab("maximum")+
  facet_wrap(~Var2, nrow = 4) +
  geom_vline(
    data = x_max_asv, 
    aes(xintercept = value), 
    color = "purple"
    ) + 
  theme_update(
    text = element_text(size = 8)
    )


ggsave(
  paste0(
    "model_assesment_hist_all_obs_sim_K_", 
    K, 
    ".png"
    ), 
  p_hist, 
  width = 12, 
  height = 6
  )
```


```{r echo=FALSE, out.width="100%", fig.caption = "Supplementary Figure 13: Predictive model check with simulated data, observed data, and a statistic G(Kij) = max{Kij}. Each facet shows the histogram of G(Kij) of each ASV in specimens from the posterior predictive distribution and the vertical line shows the value of G (Kij ) of each ASV in observed data.", fig.align="center"}
knitr::include_graphics(paste0("model_assesment_hist_all_obs_sim_K_", K, ".png"))
```


Compute $\hat{R}$ and ESS (effective sample size)

```{r eval=FALSE}
Rhat_theta <- matrix(
  nrow = dim(theta_aligned)[2], 
  ncol = dim(theta_aligned)[3]
  )

ESS_bulk_theta <- matrix(
  nrow = dim(theta_aligned)[2], 
  ncol = dim(theta_aligned)[3]
  )

ESS_tail_theta <- matrix(
  nrow = dim(theta_aligned)[2], 
  ncol = dim(theta_aligned)[3]
  )

for(sam in 1:dim(theta_aligned)[2]){
  for(top in 1:dim(theta_aligned)[3]){
    sims_theta <- matrix(
      theta_aligned[ ,sam , top], 
      nrow = (iter/2), 
      ncol = 4, 
      byrow = FALSE
      )
    Rhat_theta[sam, top] <- Rhat(sims_theta)
    ESS_bulk_theta[sam, top] <- ess_bulk(sims_theta)
    ESS_tail_theta[sam, top] <- ess_tail(sims_theta)
  }
  
}

Rhat_theta <- as.vector(Rhat_theta)
ESS_bulk_theta <- as.vector(ESS_bulk_theta)
ESS_tail_theta <- as.vector(ESS_tail_theta)

Rhat_beta <- matrix(
  nrow = dim(beta_aligned)[2], 
  ncol = dim(beta_aligned)[3]
  )
ESS_bulk_beta <- matrix(
  nrow = dim(beta_aligned)[2], 
  ncol = dim(beta_aligned)[3]
  )
ESS_tail_beta <- matrix(
  nrow = dim(beta_aligned)[2], 
  ncol = dim(beta_aligned)[3]
  )
  
for(top in 1:dim(beta_aligned)[2]){
    for(fea in 1:dim(beta_aligned)[3]){
      sims_beta <- matrix(
        beta_aligned[ , top, fea], 
        nrow = (iter/2), 
        ncol = 4, 
        byrow = FALSE)
      Rhat_beta[top, fea] <- Rhat(sims_beta)
      ESS_bulk_beta[top, fea] <- ess_bulk(sims_beta)
      ESS_tail_beta[top, fea] <- ess_tail(sims_beta)
    }
  
}

Rhat_beta <- as.vector(Rhat_beta)
ESS_bulk_beta <- as.vector(ESS_bulk_beta)
ESS_tail_beta <- as.vector(ESS_tail_beta)

Rhat <- c(Rhat_theta, Rhat_beta)


ESS_bulk <- c(ESS_bulk_theta, ESS_bulk_beta)


ESS_tail <- c(ESS_tail_theta, ESS_tail_beta)

# R hat ~ 1.05
p_rhat <- ggplot(
  data.frame(Rhat = Rhat)
  ) +
  geom_histogram(
    aes(x = Rhat), 
    fill = "lavender", 
    colour = "black", 
    bins = 100
    ) +  
  theme(
    plot.title = element_text(hjust = 0.5)
    )  +
  theme_minimal(base_size = 20) +
  xlab("")


ggsave(
  paste0("Rhat_plant_all_K_", K, ".png"), 
  p_rhat, 
  width = 9, 
  height = 6
  )

# ESS bulk and ESS tail at least 100 per Markov Chain in order to be reliable and indicate that estimates of respective posterior quantiles are reliable

p_ess_bulk <- ggplot(
  data.frame(ESS_bulk = ESS_bulk)
  ) +
  geom_histogram(
    aes(x = ESS_bulk), 
    fill = "lavender", 
    colour = "black", 
    bins = 100
    ) +
  theme(
    plot.title = element_text(hjust = 0.5)
    )   + 
  theme_minimal(
    base_size = 20
    ) +
  xlab("")


ggsave(
  paste0("ess_bulk_plant_all_K_", K, ".png"), 
  p_ess_bulk, 
  width = 9, 
  height = 6
  )

```


```{r echo=FALSE, out.width="100%", fig.caption = "Supplementary Figure 14: Effective sample size (ESS) with eleven topics.", fig.align="center"}
knitr::include_graphics(paste0("ess_bulk_plant_all_K_", K, ".png"))
```

```{r echo=FALSE, out.width="100%", fig.caption = "Supplementary Figure 15: Split Rhat with eleven topics.", fig.align="center"}
knitr::include_graphics(paste0("Rhat_plant_all_K_", K, ".png"))
```



## Differential topic analysis

We do differential topic analysis to test whether topic memberships differ across conditions.

1. Compute the median Bayesian posterior of topic proportions in each specimen. 

2. Multiply the proportions by the library size and round to an integer. This will give an abundance
of the topic in each specimen. 

3. Apply DESeq2 to identify differentially abundant topics across O and M pPNA types.

```{r eval=FALSE}
# posterior samples
theta_aligned_abun <- theta_aligned
# median Bayesian posterior of topic proportions in each specimen
median_theta_aligned_abun <- apply(
  theta_aligned_abun, 
  c(2,3), 
  median)

# Multiply the proportions by the library size and round to an integer
lib_size <- colSums(
  otu_table(ps) %>% 
    data.frame()
  )

median_theta_aligned_abun <- median_theta_aligned_abun * lib_size

median_theta_aligned_abun <- ceiling(
  median_theta_aligned_abun
  )

sam_data <- sample_data(ps) %>% 
  data.frame()

```

### Test on all specimens

We do test on all specimens. We can write DESeq2 results to LaTex

```{r eval=FALSE}
dds <- DESeqDataSetFromMatrix(
  countData = t(median_theta_aligned_abun),
  colData = sam_data,
  design= ~ pna
  )

dds <- DESeq(
  dds, 
  fitType = "mean"
  )

saveRDS(dds, file = paste0("dds_all_K_", K,".rds"))
```


```{r}
res <- results(dds_all_K_11)
res 
#writeResTable(res, fileN = paste0("dds_all_K_", K,".tex"))
```

### Test on paired-specimens
We do the test on paired-specimens.

```{r eval=FALSE}
dds <- DESeqDataSetFromMatrix(
  countData = t(median_theta_aligned_abun),
  colData = sam_data,
  design= ~  pna
  )

dds <- dds[, as.character(dds$X) %in% paired_specimens]
dds <- DESeq(
  dds, 
  fitType = "mean"
  )
 
saveRDS(
  dds, 
  file = paste0("dds_all_paired_K_", K,".rds")
  )
```

```{r}
res <- results(dds_all_paired_K_11)
res 
#writeResTable(res, fileN = paste0("dds_all_paired_K_", K,".tex"))
```
### Test on paired non-Aster specimens

We do the test on paired non-Aster specimens.

```{r eval=FALSE}
dds <- DESeqDataSetFromMatrix(
  countData = t(median_theta_aligned_abun),
  colData = sam_data,
  design= ~  pna
  )

dds <- dds[, as.character(dds$X) %in% paired_non_aster]

dds <- DESeq(
  dds, 
  fitType = "mean"
  )

saveRDS(dds, 
        file = paste0("dds_all_paired_nonaster_K_", K,".rds")
        )
```


```{r}
res <- results(dds_all_paired_nonaster_K_11)
res 
#writeResTable(res, fileN = paste0("dds_all_paired_nonaster_", K,".tex"))
```

### Test on paired Aster specimens
We do the test on paired Aster specimens.

```{r eval=FALSE}
dds <- DESeqDataSetFromMatrix(
  countData = t(median_theta_aligned_abun),
  colData = sam_data,
  design= ~  pna
  )

dds <- dds[, as.character(dds$X) %in% paired_aster]

dds <- DESeq(
  dds, 
  fitType = "mean"
  )

saveRDS(
  dds, 
  file = paste0("dds_all_paired_aster_K_", K,".rds")
  )
```

```{r}
res <- results(dds_all_paired_aster_K_11)
res 
#writeResTable(res, fileN = paste0("dds_all_paired_aster_", K,".tex"))
```

```{r include=FALSE}
rm(params, ps, stan.data, x, aster, iter, K, non_aster, paired_aster, paired_non_aster, paired_specimens, plant_colors, sam_names, res)
```


